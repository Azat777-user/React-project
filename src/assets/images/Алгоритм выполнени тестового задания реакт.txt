1) Создаем реакт приложение npx create-react-app или же yarn название прложения в данном случае user-data-table. 
2) В папке src оставим три файла App.js index.js serverWorker.js остальное удаляем. И в этих файлах удаляем все лишние импорты.
3) устанавливаем bootstrap yarn add bootstrap. 	У него две зависимости jquery и pooper и импортирум в index.js стили бутстрапа import 'bootstrap/dist/css/bootstrap.min.css'.
4) в App пишем у дивки className="container" запускаем проект yarn start проверяем все ли работает загрузился ли бутстрап.
5) Дальше формируем таблицу которая будет сортироваться берем url с минимальными данными в json формате и после переходим в app.js и в методе componentDidMount мы делаем запрос на сервер то есть когда компонента монтируется. при помощи функций fetch или axios делаем запрос и получаем ответ от сервера и выводим ответ на консоль.
6) Показываем пользователю индикатор загрузки для этого набираем loader css в адресной строке и переходим на первую ссылку loading.io создаем папку Loader там Loader.css и копируем css и создаем компоненту в файле Loader.js в компоненте задаем div с определленым классом и импортируем в app.
7) Формируем таблицу папка Table и там соотвественно компоненту в файле Table.js нам лучше создавать пезентациооные компоненты потому что чем меньше у нас классовых компонент тем быстрее будет работать наше приложение в компоненте в jsx table className="table" бутстраповский и выводим внутри thead в th соотвествующие названия полей в tbody мы выводим переданные в пропсы данные получееные от сервера перебераем массив data с помощью map(item=> tr key=item.id item.phone для того чтобы у нас сформировался уникальный ключ и не было ошибки и реакт оптимально все отрисовывал td item.firstName td item.lastName td item.email td item.phone) и импортирум этот Table в app.
8) Нам нужно показывать Loader если идет агрузка данных а если данные загрузились то показываем таблицу для этого в app создаем state={isLoading:true, data:[]} внутри сontainer в app выводим если загрузка данных идет непосредственно Loader иначе Table data={this.state.data} условие делаем тернарным оператором в методе componentDidMount когда у нас загрузятся данные то мы меняем state this.setState({isLoading:false,data cвойство массив state:data загруженные данные, так как название ключа и занчения совпадают то можем написать просто data здесь мы делаем свойству state массиву data присваивание загруженных данных из сервера data })
9) Сортировка массива для этого мы кликаем по заголовку столбца и тем самым мы сортруем элементы определенного столбца в th задаем onClick={props.onSort.bind(null,"id") th props.onSort.bind(null,"firstName") и т.д. в качестве контекста ничего не указываем но в качестве привязаного параметра мы будем указывать название столбца которое нужно сортировать } так как Table компонента глупая она просто выводит данные то callback мы передаем через пропсы то есть через свойства.
10) В app в Table передаем в качестве пропсов callback onSort={this.onSort} метод onSort(sortField заголовок сортируемого поля){для того чтобы неписать сортировку  вручную будем использовать библиотеку lodash ищем метод orderBy yarn add lodash import _ from 'lodash' создаем копию нашего массива const clonedData = this.state.data.concat() для того чтобы у нас небыло изменене стейта то есть мы будем работать скопией нашего массива теперь нам нужно отсортировать массив по определенному полю который мы получаем на входе в параметрах и в определенном направлений направление сохраняем в app state={isLoader:false,data:[],sort:'asc' по умолчанию asc или еще desc определим направление const sortType=this.state.sort==='asc' ? 'desc': 'asc' получаем отсортированный массив сonst orderedData = _.orderedBy(clonedData, sortField, sortType) и меняем стейт this.setState({data:orderedData, sort:sortType, запоминаем то поле которое мы отсортировали по умолчанию это пишем в основном state sortField: 'id' а тут пишем sortField:sortField })} } создаем в самом app.
10) Теперь отобрааем сортировку визуально тое сть создаем иконку либо текст для этого в Table передаем sort={this.state.sort} sortField={this.state.sortField} и в самом Table.js в th мы проверяем если у нас {props.sortField===id?props.sort:null} мы сортировали именно id то показываем направление сортировки sort иначе ниичего не показываем и по умолчанию у нас отображается asc хотя сортировки по этому направлению не было и чтобы невводить пользователя в заблуждение мы при получений данных в componentDidMount мы отсортируем поле data и в componentDidMount в this.setState(data: _orderBy(data, this.state.sortField, this.state.sort)) 
11) При клике на какую то из строк нам нужно показать детальное отображение данной строки для этого каждому элементу tr в Table.js добавим обработчик событий onClick={props.onRowSelect.bind(null, item по которому мы хотим кликнуть)} в app в Table onRowSelect={this.onRowSelect} onRowSelect= row объект row объект по которому кликнули=>{} 
12) Теперь при клике на какую то строчку нам необходимо соотвественно отрисовывать ее под таблицей для этого в state={объявим новое свойство row:null} и при клике на строчку мы будем делать onRowSelect= row => {this.setState({row})} и в container мы проверяем если в row что то есть {this.state.row ? <DetailRowView person={this.state.row} /> : null }
13) Создаем компоненту папку DetailRowView и вней файл DetailRowView и в ней непосредственно компоненту DetailRowView и так как в сам компонент мы передаем person и в пропсах компоненты DetailRowView = ({person} делаем деструктуризацию пропсов и получать объект person) 